---
title: "Simulation Study (Section 3)"
author: "Beniamino Hadj-Amar and Jack Jewson"
date: "15 March 2024"
output: html_document
---

## Preamble {.tabset}

### Working directory

+ Change this to be the directory that the stan files are saved in 

```{r setwd, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE}

my_dir <- "..."

```

### Packages

Loading the required packages.

```{r packages, include=TRUE, echo=TRUE, eval=TRUE, cache=FALSE}

library("farff")
library("rstan")
library("bayesplot")
library("bridgesampling")
library("mvtnorm")
library("RColorBrewer")
library(matrixStats)

library("LaplacesDemon")
library("actuar")
library("ggplot2")

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

library(tikzDevice)
options(tz="CA")
options(tikzLatexPackages 
   =c(getOption( "tikzLatexPackages" ),"\\usepackage{amsfonts}", "\\usepackage[utf8]{inputenc}", "\\usetikzlibrary{calc}" ))

```

```{r utils, include=TRUE, echo=TRUE, eval=TRUE, cache=FALSE}

setwd(my_dir)

source("include/util.R")
source("include/util_VARHMM.R")
source("include/util_data/util_data_Gesture_Phase.R")
source("include/util_approxVARHSMM.R")
source("include/util_NBapproxVARHSMM.R")
source("include/util_VAR_l1_ball_priorSpecification.R")


```

### stan file compilations


Loading and compiling .stan programs

```{r stan_files, include=TRUE, echo=TRUE, eval = TRUE,  cache=FALSE}

setwd(my_dir)

# 1) HMM_l1
VARHMM_l1ball_stan <- stan_model(file = "stan/VARHMM_l1ball.stan")
# 2) HSMM_l1
NBapproxVARHSMM_sparse_l1ball_stan <- stan_model(file = "stan/NBapproxVARHSMM_sparse_l1ball.stan") #
# 3) HSMM-LASSO-NLP
NBapproxVARHSMM_sparse_NLP_stan <- stan_model(file = "stan/NBapproxVARHSMM_sparse_NLP.stan") # 
# 4) (our proposed approach) HSMM-l1-NLP
NBapproxVARHSMM_sparse_l1ball_NLP_stan <- stan_model(file = "stan/NBapproxVARHSMM_sparse_l1ball_NLP.stan") # 

```

# Data {.tabset}

## Data Simulation

```{r data_simulation, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

#### -------- Simulation Study (Section 3) -------- ####


# --- parameters simulation

K <- 3 # number of states
D <- 5 # dimensionality
P <- 2 # autoregressive order

Sigma <- list()
beta_0 <- list()
beta <- lapply(1:K, function(k) {array(NA, dim = c(D, D, P))})

sparsity_level <- c(0.7, 0.3, 0.9) # different per state.
abs_beta_low <- 0.2
abs_beta_up <- 0.8

# --- generating parameters
set.seed(14)

# sparse VAR emissions and covariance matrix
for (kk in 1:K) {
  beta[[kk]] <- generate_sparse_beta(D, P, sparsity_level[kk], 
                                     abs_beta_low, abs_beta_up)
  beta_0[[kk]] <- runif(D, -4, 4) + (kk-1) # mean vector 
  Sigma[[kk]] <- generate_covariance(D) # covariance (remark: high variances)
}

# rate & dispersion (neg binom)
lambda <- c(2, 10, 7)
phi <- c(0.25, 3, 5)

# - transition probs
gamma <- matrix(c(0, 0.5, 0.5,
                  0.5, 0, 0.5,
                  0.5, 0.5, 0), K, K, byrow= T)

# initial prob
delta <- c(1.0, 0.0, 0.0)

# list all parameters
parms_true <- list()
parms_true$K <- K
parms_true$D <- D
parms_true$P <- P
parms_true$Sigma <- Sigma
parms_true$beta_0 <- beta_0
parms_true$beta <- beta 
parms_true$lambda <- lambda
parms_true$phi <- phi
parms_true$gamma <- gamma
parms_true$delta <- delta


# --- generating observations
N <- 400
simul <- NBapproxVARHSMM_generate(N, parms_true, scale = T, plt = F)
obs <- simul$obs
state <- simul$state


```

```{r simulation_data_plot_tikz, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE, fig.height = 2, fig.width = 5, dev = "tikz"}

par(mar = c(3.1, 3.3, 1.5, 1.1)) # bottom, left, top, right
#par(mar = c(5.1, 4.1, 4.1, 2.1)) # Default
#par(mgp = c(3, 1, 0)) # Default - location of xlab and ylab, tick-mark labels, tick marks.
par(mgp = c(2.15, 1, 0))
par(cex.lab = 1., cex.axis = 1.00, cex.main = 1.00)
simulation_plot(simul, plt_all = TRUE, plt_univ = FALSE)


```

# Prior Specification

## Comparable Dwell Priors

```{r Dirichelt_prior, include=TRUE, echo=TRUE, eval=TRUE, cache=TRUE}

## State 1

mean_target <- 10
var_target <- 5^2

dirichlet_set <- optim(par = c(5, 5), fn = function(par){geomDwell_mean_var_target_error(alpha_i = exp(par[1]), beta_i = exp(par[2]), mean_target, var_target)})

exp(dirichlet_set$par)

alpha_1 <- c(exp(dirichlet_set$par[1]), exp(dirichlet_set$par[2])/2, exp(dirichlet_set$par[2])/2)

gamma_set <- optim(par = c(5, 5), fn = function(par){NBDwell_mean_var_target_error(a_0 = exp(par[1]), b_0 = exp(par[2]), mean_target, var_target)})

exp(gamma_set$par)

a_01 <- exp(gamma_set$par[1])
b_01 <- exp(gamma_set$par[2])

## State 2

mean_target <- 10
var_target <- 5^2

dirichlet_set <- optim(par = c(5, 5), fn = function(par){geomDwell_mean_var_target_error(alpha_i = exp(par[1]), beta_i = exp(par[2]), mean_target, var_target)})

exp(dirichlet_set$par)

alpha_2 <- c(1/2*exp(dirichlet_set$par[2]), exp(dirichlet_set$par[1]), 1/2*exp(dirichlet_set$par[2]))

gamma_set <- optim(par = c(5, 5), fn = function(par){NBDwell_mean_var_target_error(a_0 = exp(par[1]), b_0 = exp(par[2]), mean_target, var_target)})

exp(gamma_set$par)

a_02 <- exp(gamma_set$par[1])
b_02 <- exp(gamma_set$par[2])

## State 3

mean_target <- 10
var_target <- 5^2

dirichlet_set <- optim(par = c(5, 5), fn = function(par){geomDwell_mean_var_target_error(alpha_i = exp(par[1]), beta_i = exp(par[2]), mean_target, var_target)})

exp(dirichlet_set$par)

alpha_3 <- c(1/2*exp(dirichlet_set$par[2]), 1/2*exp(dirichlet_set$par[2]), exp(dirichlet_set$par[1]))

gamma_set <- optim(par = c(5, 5), fn = function(par){NBDwell_mean_var_target_error(a_0 = exp(par[1]), b_0 = exp(par[2]), mean_target, var_target)})

exp(gamma_set$par)

a_03 <- exp(gamma_set$par[1])
b_03 <- exp(gamma_set$par[2])

```

## VAR Coefficients (l1-ball)

```{r prior_specification_beta_sparsity, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

sparsity_level <- 0.75
prob_stable <- 0.95
N_MC <- 5000

P <- 2

## Setting lamabda ##

lambda_vec <- seq(0.1, 1, length.out = 20)
sparse_VAR_DExp_stability_prob_eval <- rep(NA, 20)

for(j in 1:20){
  sparse_VAR_DExp_stability_prob_eval[j] <- mean(sparse_VAR_DExp_stability_prob(N_MC, D, P, sparsity_level, lambda = lambda_vec[j])  == 1)
  cat("lambda", j, "done", "\n")
}

lambda_beta_set <- lambda_vec[which.min(abs(sparse_VAR_DExp_stability_prob_eval - prob_stable))]


## Setting r_alpha | lambda ##

alpha_r_vec <- seq(0.1, 1, length.out = 20)
theta_sparsity_eval <- rep(NA, 20)

for(j in 1:20){
  theta_sparsity_eval[j] <- mean(theta_prior_gen_l1_ball(D*D*P, r_alpha = alpha_r_vec[j], beta_gen = function(p){rlaplace(p, 0, lambda_beta_set)}, N_MC = 5000)  == 0)
  cat("r_alpha", j, "done", "\n")
}

alpha_r_set <- alpha_r_vec[which.min(abs(theta_sparsity_eval - sparsity_level))]

```

## Others

```{r prior_specification_others, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

## Covariance
Omega_shape <- 1
tau_loc <- 0.5
tau_scale <- 0.5

```

# VAR-HMM {.tabset}

## Model settings

```{r VARHMM_model_settings, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

N_MCMC <- 5000
K <- 3
P <- 2

```

## Prior Specification

```{r VARHMM_dwell_prior_specification, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

alpha_0 <- matrix(NA, nrow = K, ncol = K)
alpha_0[1,] <- alpha_1
alpha_0[2,] <- alpha_2
alpha_0[3,] <- alpha_3

```

## MCMC

```{r VARHMM_l1ball_fit, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

# data
VARHMM_l1ball_data <- list(N = N, D = D, K = K, 
                   P = P, y = obs, 
                   beta_0_loc = matrix(0, K, D), 
                   beta_0_scale = lambda_beta_set, 
                   beta_loc = 0, beta_scale = lambda_beta_set,
                   tau_loc = tau_loc, tau_scale = tau_scale, 
                   #alpha_0 = alpha_0, 
                   alpha_0_rest = matrix(alpha_0[!diag(K)], nrow = K, ncol = K-1),
                   alpha_0_diag = diag(alpha_0),
                   Omega_shape = Omega_shape,
                   r_alpha = alpha_r_set)

# fit 
VARHMM_l1ball_fit <- sampling(object = VARHMM_l1ball_stan,
                       data = VARHMM_l1ball_data, seed = 123, 
                       chains = 1, iter = 1000 + N_MCMC, 
                       warmup = 1000)


VARHMM_l1ball_params <- rstan::extract(VARHMM_l1ball_fit)

get_elapsed_time(VARHMM_l1ball_fit)

VARHMM_l1ball_bridge <- bridge_sampler(VARHMM_l1ball_fit, silent = TRUE)

```

saving to RData

```{r VARHMM_l1ball_fit_save, include=TRUE,echo=TRUE, eval = FALSE,  cache=FALSE}

save(VARHMM_l1ball_fit, VARHMM_l1ball_bridge, file = "VARHMM_l1ball_fit_simulation.RData")

```

## Chain Diag

```{r VARHMM_l1ball_diag, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

fit_summary <- summary(VARHMM_l1ball_fit)

mean(fit_summary$summary[1:(K*K + 2*K*D + K*D^2 + K*D*D*P + K),9], na.rm = TRUE)

traceplot(VARHMM_l1ball_fit, pars = c("ray[1]", "ray[2]", "ray[3]", "lp__"))
```

## Posterior Predictive 

```{r VARHMM_l1ball_posterior_predictive_rn, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}


VAR_HMM_predictive <- VARHMM_get_predictive(VARHMM_l1ball_fit, obs, pseudo = FALSE, 
                                             L1_ball = TRUE, ndraw = 100)

```

```{r VARHMM_l1ball_posterior_predictive, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}
p_hat <- VAR_HMM_predictive$log_pred_density
z_hat <- VAR_HMM_predictive$z_hat
y_hat <- VAR_HMM_predictive$y_hat

# plot posterior predictive
K <- dim(rstan::extract(VARHMM_l1ball_fit)$beta_0)[2]
plotPosteriorPredictive(obs, y_hat, z_hat, K)

state[1:20]
z_hat[1:20]
## this is a vector the length of the states saying which estimated states corresponds to the which real state - then below I keep the dat agenerating as it is and repce by state_corresponce indexes
true_state_order <- c(1, 2, 3)
estimated_state_order_HMM <- c(2, 3, 1)
state_correspondence <- c(3, 1, 2)
#state_correspondence <- c(1, 3, 2)
state[1:20]
state_correspondence[z_hat[1:20]]

VARHMM_l1ball_state_errors <- sum(abs(state != state_correspondence[z_hat]))
VARHMM_l1ball_state_errors

VARHMM_l1ball_state_errors/N

VARHMM_l1ball_llh <- sum(p_hat)
VARHMM_l1ball_llh

```

## State Probabilities

```{r VARHMM_l1ball_state_probabilities, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

par(mfrow = c(2, 1))
plotPosteriorPredictive(obs, y_hat, z_hat, K)
VARHMM_plotStateProbs(VARHMM_l1ball_fit, obs, pseudo = FALSE, L1_ball = TRUE)

VARHMM_plotStateProbs_state_probs <- VARHMM_stateProbs(VARHMM_l1ball_params, obs, pseudo = FALSE, L1_ball = TRUE)

#VARHMM_plotStateProbs_state_probs_Bayesian <- VARHMM_stateProbs_Bayesian(sims = VARHMM_l1ball_params, obs, pseudo = FALSE, L1_ball = TRUE)


```

## Breir Score Selection (State Estimation)

```{r VARHMM_l1ball_state_probabilities_BreirScore, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

VARHMM_l1ball_breir_score <- sum((VARHMM_plotStateProbs_state_probs[estimated_state_order_HMM[1],] - (state == 1))^2)/(N) + sum((VARHMM_plotStateProbs_state_probs[estimated_state_order_HMM[2],] - (state == 2))^2)/(N) + sum((VARHMM_plotStateProbs_state_probs[estimated_state_order_HMM[3],] - (state == 3))^2)/(N)
VARHMM_l1ball_breir_score
```

## VAR coefficients

```{r VARHMM_l1ball_VAR, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}


# posterior estimate beta (projected)
beta_est <- get_beta_est(VARHMM_l1ball_params, L1_ball = TRUE, mat = TRUE)

simul$state[1:20]
state_correspondence[VAR_HMM_predictive$z_hat[1:20]]

beta_est[estimated_state_order_HMM[1], , ,]; parms_true$beta[[1]]
beta_est[estimated_state_order_HMM[2], , ,]; parms_true$beta[[2]]
beta_est[estimated_state_order_HMM[3], , ,]; parms_true$beta[[3]]

sum(abs(beta_est[estimated_state_order_HMM[1], , ,] - drop(parms_true$beta[[1]])))
sum(abs(beta_est[estimated_state_order_HMM[2], , ,] - drop(parms_true$beta[[2]])))
sum(abs(beta_est[estimated_state_order_HMM[3], , ,] - drop(parms_true$beta[[3]])))

VARHMM_l1ball_beta1_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HMM[1], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[1]])))
VARHMM_l1ball_beta1_MSE

VARHMM_l1ball_beta2_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HMM[2], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[2]])))
VARHMM_l1ball_beta2_MSE

VARHMM_l1ball_beta3_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HMM[3], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[3]])))
VARHMM_l1ball_beta3_MSE

plot.heat(Matrix = beta_est[estimated_state_order_HMM[1],,,1], Xlab="", Ylab="", Main="Estimated theta", limit=c(-1,1))
plot.heat(Matrix = beta_est[estimated_state_order_HMM[1],,,2], Xlab="", Ylab="", Main="Estimated theta", limit=c(-1,1))

plot.heat(Matrix = beta_est[estimated_state_order_HMM[2],,,1], Xlab="", Ylab="", Main="Estimated theta", limit=c(-1,1))
plot.heat(Matrix = beta_est[estimated_state_order_HMM[2],,,2], Xlab="", Ylab="", Main="Estimated theta", limit=c(-1,1))

plot.heat(Matrix = beta_est[estimated_state_order_HMM[3],,,1], Xlab="", Ylab="", Main="Estimated theta", limit=c(-1,1))
plot.heat(Matrix = beta_est[estimated_state_order_HMM[3],,,2], Xlab="", Ylab="", Main="Estimated theta", limit=c(-1,1))
```

Does the dwell distribution potentially affect the $\theta$ and the probabilities? It would be cool if so.

## Inclusion Probabilities

```{r VARHMM_l1ball_p_inclusion, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

# - inclusion probabilities 
p_est <- get_inclusion_sims(VARHMM_l1ball_params, p_est = TRUE)$p_est
p_est[estimated_state_order_HMM[1], , , 1]; parms_true$beta[[1]]
p_est[estimated_state_order_HMM[2], , , 1]; parms_true$beta[[2]]
p_est[estimated_state_order_HMM[3], , , 1]; parms_true$beta[[3]]


par(mfrow = c(1, 2))
plot.heat(Matrix = parms_true$beta[[1]][,,1], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HMM[1], , , 1], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

par(mfrow = c(1, 2))
plot.heat(Matrix = parms_true$beta[[1]][,,2], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HMM[1], , , 2], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[2]][,,1], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HMM[2], , , 1], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[2]][,,2], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HMM[2], , , 2], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[3]][,,1], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HMM[3], , , 1], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[3]][,,2], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HMM[3], , , 2], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

```

### Breir Score Selection (VAR estimation)

```{r VARHMM_l1ball_NLP_Breir_Score_Selection, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

parms_true_beta <- array(NA, dim = c(K, D, D, P))
parms_true_beta[estimated_state_order_HMM[1], , ,] <- parms_true$beta[[1]]
parms_true_beta[estimated_state_order_HMM[2], , ,] <- parms_true$beta[[2]]
parms_true_beta[estimated_state_order_HMM[3], , ,] <- parms_true$beta[[3]]

VARHMM_l1ball_breir_score_beta <- sum((p_est - (parms_true_beta != 0))^2)/(K*D*D*P)
VARHMM_l1ball_breir_score_beta

VARHMM_breir_score_beta <- sum((1 - (parms_true_beta != 0))^2)/(K*D*D*P)
VARHMM_breir_score_beta
```

## Covariance Estimation

Plot cov2cors, the standardisation only acted marginally so should leave the correlations in tact

```{r VARHMM_l1ball_cov_params, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

### Sigma 
# - covariance matricies
Sigma_est <- list()
for (k in 1:K) {
  Sigma.sims <- array(NA, dim = c(N_MCMC, D, D))# where is K in here?
  for (tt in 1:N_MCMC) {
    Omega <- VARHMM_l1ball_params$L_Omega[tt, k, ,] %*% t(VARHMM_l1ball_params$L_Omega[tt, k, ,])
    tau <- VARHMM_l1ball_params$tau[tt, k, ]
    Sigma.sims[tt, ,] <- quad_form_diag(Omega, tau)
  }
  Sigma_est[[k]] <- apply(Sigma.sims, c(2, 3), mean)
}; Sigma_est;

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HMM[1]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[1]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HMM[2]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[2]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HMM[3]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[3]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))

```

## Dwell Distribution 

```{r VARHMM_l1ball_dwell, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

apply(VARHMM_l1ball_params$gamma, c(2, 3), mean)

mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[1],estimated_state_order_HMM[1]]))
mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[2],estimated_state_order_HMM[2]]))
mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[3],estimated_state_order_HMM[3]]))

parms_true$lambda + 1

VARHMM_l1ball_bridge$logml

```

# VAR-HSMM Negative Binomial {.tabset}

## Model settings

```{r NBapproxVARHSMM_model_settings, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

N_MCMC <- 5000
K <- 3
P <- 2

m <- c(15, 15, 15)

```

## Local Prior for phi

$phi^{-1} \sim \mathcal{G}(c_0, c_0 + 1) \Rightarrow phi \sim \mathcal{IG}(c_0, c_0 + 1) $

```{r LP_IG_phi_prior_set, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

# a_0_phi_LP <- 2 # mode is 1
# b_0_phi_LP <- a_0_phi_LP + 1# mode is 1
# 
# pinvgamma(4, shape = a_0_phi_LP, scale = b_0_phi_LP) - pinvgamma(0.25, shape = a_0_phi_LP, scale = b_0_phi_LP)

a_0_phi_LP <- 4
b_0_phi_LP <- 5 # mode is 1

pinvgamma(4, shape = a_0_phi_LP, scale = b_0_phi_LP) - pinvgamma(0.25, shape = a_0_phi_LP, scale = b_0_phi_LP)
phim1_seq <- seq(0, 10, length.out = 1000)
plot(phim1_seq, dgamma(phim1_seq, shape = a_0_phi_LP, rate = b_0_phi_LP), xlab = "1/phi", ylab = "Density", lwd = 3, type = "l")

```

## Prior Specification

```{r NBapproxVARHSMM_prior_specification, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

a_0 <- c(a_01, a_02, a_03)
b_0 <- c(b_01, b_02, b_03)

alpha_0 <- matrix(c(alpha_1[-1], alpha_2[-2], alpha_3[-3]), nrow = K, ncol = K-1, byrow = TRUE)

```

## MCMC

```{r NBapproxVARHSMM_l1ball_fit, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

# data
NBapproxVARHSMM_l1ball_data <- list(N = N, D = D, K = K, 
                   P = P, y = obs, 
                   m = m,
                   beta_0_loc = matrix(0, K, D), 
                   beta_0_scale = lambda_beta_set, 
                   beta_loc = 0, beta_scale = lambda_beta_set,
                   tau_loc = tau_loc, tau_scale = tau_scale, 
                   Omega_shape = Omega_shape,
                   r_alpha = alpha_r_set,
                   a_0_lambda = a_0, 
                   b_0_lambda = b_0, 
                   a_0_phi = a_0_phi_LP, 
                   b_0_phi = b_0_phi_LP, 
                   alpha_0 = alpha_0)

# fit 
NBapproxVARHSMM_l1ball_fit <- sampling(
     #object = NBapproxVARHSMM_l1ball_stan,
     object = NBapproxVARHSMM_sparse_l1ball_stan,
     data = NBapproxVARHSMM_l1ball_data, seed = 123, 
     chains = 1, iter = 1000 + N_MCMC, 
     warmup = 1000)


NBapproxVARHSMM_l1ball_params <- rstan::extract(NBapproxVARHSMM_l1ball_fit)

get_elapsed_time(NBapproxVARHSMM_l1ball_fit)

NBapproxVARHSMM_l1ball_bridge <- bridge_sampler(NBapproxVARHSMM_l1ball_fit, silent = TRUE)

```

saving to RData

```{r NBapproxVARHSMM_l1ball_fit_save, include=TRUE,echo=TRUE, eval = FALSE,  cache=FALSE}

save(NBapproxVARHSMM_l1ball_fit, NBapproxVARHSMM_l1ball_bridge, file = "NBapproxVARHSMM_l1ball_fit_simulation.RData")
```

## Chain Diag

```{r NBapproxVARHSMM_l1ball_diag, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

fit_summary <- summary(NBapproxVARHSMM_l1ball_fit)

mean(fit_summary$summary[1:(K*K + 2*K*D + K*D^2 + K*D*D*P + K),9], na.rm = TRUE)

traceplot(NBapproxVARHSMM_l1ball_fit, pars = c("ray[1]", "ray[2]", "ray[3]", "lp__"))
```

## Posterior Predictive 

```{r NBapprox_VAR_HSMM_l1ball_posterior_predictive_rn, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}


NBapprox_VAR_HSMM_predictive <- NBapproxVARHSMM_getPredictive(NBapproxVARHSMM_l1ball_fit , m, obs, 
                                                  pseudo = FALSE, 
                                                  L1_ball = TRUE, ndraw = 50)
```

```{r NBapprox_VAR_HSMM_l1ball_posterior_predictive, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}
p_hat <- NBapprox_VAR_HSMM_predictive$log_pred_density
z_hat <- NBapprox_VAR_HSMM_predictive$z_hat
y_hat <- NBapprox_VAR_HSMM_predictive$y_hat

# plot posterior predictive
K <- dim(rstan::extract(NBapproxVARHSMM_l1ball_fit)$beta_0)[2]
plotPosteriorPredictive(obs, y_hat, z_hat, K)

state[1:20]
z_hat[1:20]
## this is a vector the length of the states saying which estimated states corresponds to the which real state - then below I keep the dat agenerating as it is and repce by state_corresponce indexes
true_state_order <- c(1, 2, 3)
estimated_state_order_HSMM <- c(1, 2, 3)
state_correspondence <- true_state_order[estimated_state_order_HSMM]

NBapproxVARHSMM_l1ball_state_errors <- sum(abs(state != state_correspondence[z_hat]))
NBapproxVARHSMM_l1ball_state_errors

NBapproxVARHSMM_l1ball_state_errors/N

NBapproxVARHSMM_l1ball_llh <- sum(p_hat)
NBapproxVARHSMM_l1ball_llh
VARHMM_l1ball_llh
```

## State Probabilities

```{r NBapproxVARHSMM_l1ball_state_probabilities, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

par(mfrow = c(2, 1))
plotPosteriorPredictive(obs, y_hat, z_hat, K)

NBapproxVARHSMM_plotStateProbs(NBapproxVARHSMM_l1ball_fit, obs, m = m, pseudo = FALSE, L1_ball = TRUE)

NBapproxVARHSMM_plotStateProbs_state_probs <- NBapproxVARHSMM_stateProbs(NBapproxVARHSMM_l1ball_params, obs, m = m, pseudo = FALSE, L1_ball = TRUE)

#NBapproxVARHSMM_plotStateProbs_state_probs_Bayesian <- NBapproxVARHSMM_stateProbs_Bayesian(sims = NBapproxVARHSMM_l1ball_params, obs, m = m, pseudo = FALSE, L1_ball = TRUE)

```

## Breir Score Selection (state estimation)

```{r NBapproxVARHSMM_l1ball_state_probabilities_BreirScore, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

m_temp <- c(0, cumsum(m))

NBapproxVARHSMM_l1ball_breir_score <- sum((colSums(NBapproxVARHSMM_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM[1]] + 1):m_temp[estimated_state_order_HSMM[1]+1],]) - (state == 1))^2)/(N) + sum((colSums(NBapproxVARHSMM_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM[2]] + 1):m_temp[estimated_state_order_HSMM[2]+1],]) - (state == 2))^2)/(N) + sum((colSums(NBapproxVARHSMM_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM[3]] + 1):m_temp[estimated_state_order_HSMM[3]+1],]) - (state == 3))^2)/(N)

NBapproxVARHSMM_l1ball_breir_score
```

## VAR coefficients

```{r NBapproxVARHSMM_l1ball_VAR_params, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

theta_sims <- get_theta_sims(NBapproxVARHSMM_l1ball_params)

# posterior estimate beta (projected)
beta_est <- get_beta_est(NBapproxVARHSMM_l1ball_params, L1_ball = TRUE, mat = TRUE)

simul$state[1:20]
state_correspondence[NBapprox_VAR_HSMM_predictive$z_hat[1:20]]

beta_est[estimated_state_order_HSMM[1], , ,]; parms_true$beta[[1]]
beta_est[estimated_state_order_HSMM[2], , ,]; parms_true$beta[[2]]
beta_est[estimated_state_order_HSMM[3], , ,]; parms_true$beta[[3]]

sum(abs(beta_est[estimated_state_order_HSMM[1], , ,] - drop(parms_true$beta[[1]])))
sum(abs(beta_est[estimated_state_order_HSMM[2], , ,] - drop(parms_true$beta[[2]])))
sum(abs(beta_est[estimated_state_order_HSMM[3], , ,] - drop(parms_true$beta[[3]])))

NBapproxVARHSMM_l1ball_beta1_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HSMM[1], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[1]])))
NBapproxVARHSMM_l1ball_beta1_MSE

NBapproxVARHSMM_l1ball_beta2_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HSMM[2], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[2]])))
NBapproxVARHSMM_l1ball_beta2_MSE

NBapproxVARHSMM_l1ball_beta3_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HSMM[3], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[3]])))
NBapproxVARHSMM_l1ball_beta3_MSE
```

### Inclusion Probabilities

```{r NBapproxVARHSMM_l1ball_Inclusion_probabilities_params, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

# - inclusion probabilities 
p_est <- get_inclusion_sims(NBapproxVARHSMM_l1ball_params, p_est = TRUE)$p_est
p_est[estimated_state_order_HSMM[1], , , 1]; parms_true$beta[[1]]
p_est[estimated_state_order_HSMM[2], , , 1]; parms_true$beta[[2]]
p_est[estimated_state_order_HSMM[3], , , 1]; parms_true$beta[[3]]


par(mfrow = c(1, 2))
plot.heat(Matrix = parms_true$beta[[1]][,,1], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM[1], , , 1], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

par(mfrow = c(1, 2))
plot.heat(Matrix = parms_true$beta[[1]][,,2], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM[1], , , 2], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[2]][,,1], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM[2], , , 1], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[2]][,,2], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM[2], , , 2], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[3]][,,1], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM[3], , , 1], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[3]][,,2], Xlab="", Ylab="", Main="Generated beta", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM[3], , , 2], Xlab="", Ylab="", Main="Estimated p", limit=c(0,1))

```

### Breir Score Selection (parameter estimation)

```{r NBapproxVARHSMM_l1ball_Breir_Score_Selection, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

parms_true_beta <- array(NA, dim = c(K, D, D, P))
parms_true_beta[estimated_state_order_HSMM[1], , ,] <- parms_true$beta[[1]]
parms_true_beta[estimated_state_order_HSMM[2], , ,] <- parms_true$beta[[2]]
parms_true_beta[estimated_state_order_HSMM[3], , ,] <- parms_true$beta[[3]]

NBapproxVARHSMM_l1ball_breir_score_beta <- sum((p_est - (parms_true_beta != 0))^2)/(K*D*D*P)
NBapproxVARHSMM_l1ball_breir_score_beta

```

## Covariance Estimation

Plot cov2cors, the standardisation only acted marginally so should leave the correlations in tact

```{r NBapproxVARHSMM_l1ball_cov_params, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

### Sigma 
# - covariance matricies
Sigma_est <- list()
for (k in 1:K) {
  Sigma.sims <- array(NA, dim = c(N_MCMC, D, D))# where is K in here?
  for (tt in 1:N_MCMC) {
    Omega <- NBapproxVARHSMM_l1ball_params$L_Omega[tt, k, ,] %*% t(NBapproxVARHSMM_l1ball_params$L_Omega[tt, k, ,])
    tau <- NBapproxVARHSMM_l1ball_params$tau[tt, k, ]
    Sigma.sims[tt, ,] <- quad_form_diag(Omega, tau)
  }
  Sigma_est[[k]] <- apply(Sigma.sims, c(2, 3), mean)
}; Sigma_est; 

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM[1]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[1]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM[2]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[2]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM[3]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[3]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))
```

## Dwell Parameters

```{r NBapproxVARHSMM_l1ball_dwell_parameters, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

colMeans(NBapproxVARHSMM_l1ball_params$lambda)[estimated_state_order_HSMM]

parms_true$lambda

mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[1],estimated_state_order_HMM[1]]))
mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[2],estimated_state_order_HMM[2]]))
mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[3],estimated_state_order_HMM[3]]))

colMeans(1/NBapproxVARHSMM_l1ball_params$phim1)[estimated_state_order_HSMM]

parms_true$phi

plot(density(NBapproxVARHSMM_l1ball_params$phim1[,1]), xlab = "phi^{-1}", ylab = "Density", lwd = 3)
#points(phim1_seq, dgamma(phim1_seq, shape = a_0_phi_LP, rate = b_0_phi_LP), lwd = 3, type = "l", lty = 2, col = "red")
points(phim1_seq, dinvgamma(phim1_seq, shape = a_0_phi_LP, scale = b_0_phi_LP), lwd = 3, lty = 2, type = "l", col = "red")
legend("topright", legend = c("Prior", "Posterior"), col = c("red", "black"), lwd = c(3, 3), lty = c(2, 1), bty = "n")
plot(density(NBapproxVARHSMM_l1ball_params$phim1[,2]), xlab = "phi^{-1}", ylab = "Density", lwd = 3)
points(phim1_seq, dinvgamma(phim1_seq, shape = a_0_phi_LP, scale = b_0_phi_LP), lwd = 3, lty = 2, type = "l", col = "red")
legend("topright", legend = c("Prior", "Posterior"), col = c("red", "black"), lwd = c(3, 3), lty = c(2, 1), bty = "n")
plot(density(NBapproxVARHSMM_l1ball_params$phim1[,3]), xlab = "phi^{-1}", ylab = "Density", lwd = 3)
points(phim1_seq, dinvgamma(phim1_seq, shape = a_0_phi_LP, scale = b_0_phi_LP), lwd = 3, lty = 2, type = "l", col = "red")
legend("topright", legend = c("Prior", "Posterior"), col = c("red", "black"), lwd = c(3, 3), lty = c(2, 1), bty = "n")

NBapproxVARHSMM_l1ball_bridge$logml
VARHMM_l1ball_bridge$logml

```

# VAR-HSMM Negative Binomial - NLP {.tabset}

## Model settings

```{r NBapproxVARHSMM_NLP_model_settings, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

N_MCMC <- 5000
K <- 3
P <- 2

m <- c(15, 15, 15)

```

## NLP specification

```{r NLP_prior_set, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

rhom1_seq <- seq(0, 10, length.out = 100)
ind_of_1 <- which.min(abs(rhom1_seq - 1))
rhom1_seq[ind_of_1]

## State 1

p_1 <- apply(VARHMM_l1ball_params$gamma, c(2, 3), mean)[1, 1]

TVD_NegBinom_Geom_HMM_fit1 <- rep(NA, 100)
for(i in 1:100){
  TVD_NegBinom_Geom_HMM_fit1[i] <- TVD_NegBinom_Geom_rhom1(p = p_1, rhom1 = rhom1_seq[i], x_thresh = 1000)
}

rhom1_lower_1 <- rhom1_seq[which.min(abs(TVD_NegBinom_Geom_HMM_fit1[1:ind_of_1] - 0.1))]
rhom1_upper_1 <- rhom1_seq[(ind_of_1 - 1) + which.min(abs(TVD_NegBinom_Geom_HMM_fit1[ind_of_1:100] - 0.1))]


plot(rhom1_seq, TVD_NegBinom_Geom_HMM_fit1, xlab = "1/rho", ylab = "Geom - NB TVD State 1", type = "l", lwd = 3)
abline(v = rhom1_lower_1, lwd = 3, lty = 2, col = "red")
abline(v = rhom1_upper_1, lwd = 3, lty = 2, col = "red")
abline(h = 0.1, lwd = 1, col = "grey")

#tau_set_1 <- optimise(f = function(tau){abs(integrate(f = function(phi){dpMOM_phi(phi, tau, sigma2 = 1)}, lower = rhom1_lower_1, upper = rhom1_upper_1)$value - 0.01)}, lower = 0.01, upper = 10)
tau_set_1 <- optimise(f = function(tau){abs(integrate(f = function(phi){dpeMOM_phi(phi, tau, sigma2 = 1)}, lower = rhom1_lower_1, upper = rhom1_upper_1)$value - 0.01)}, lower = 0.01, upper = 10)

phim1_seq <- seq(0, 5, length.out = 1000)
#plot(phim1_seq, dpMOM_phi(phim1_seq, tau = tau_set_1$minimum, sigma2 = 1), lwd = 3, type = "l", xlab = "1/phi", ylab = "pi(1/phi)", main = "NLP 1/phi - state 1")
plot(phim1_seq, dpeMOM_phi(phim1_seq, tau = tau_set_1$minimum, sigma2 = 1), lwd = 3, type = "l", xlab = "1/phi", ylab = "pi(1/phi)", main = "NLP 1/phi - state 1")
abline(v = rhom1_lower_1, lwd = 3, lty = 2, col = "red")
abline(v = rhom1_upper_1, lwd = 3, lty = 2, col = "red")
points(phim1_seq, dinvgamma(phim1_seq, shape = 2, scale = 3), lwd = 3, lty = 2, type = "l")
points(phim1_seq, dgamma(phim1_seq, shape = 3, rate = 2), lwd = 3, lty = 2, type = "l", col = "blue")

## State 2

p_2 <- apply(VARHMM_l1ball_params$gamma, c(2, 3), mean)[2, 2]

TVD_NegBinom_Geom_HMM_fit2 <- rep(NA, 100)
for(i in 1:100){
  TVD_NegBinom_Geom_HMM_fit2[i] <- TVD_NegBinom_Geom_rhom1(p = p_2, rhom1 = rhom1_seq[i], x_thresh = 1000)
}

rhom1_lower_2 <- rhom1_seq[which.min(abs(TVD_NegBinom_Geom_HMM_fit2[1:ind_of_1] - 0.1))]
rhom1_upper_2 <- rhom1_seq[(ind_of_1 - 1) + which.min(abs(TVD_NegBinom_Geom_HMM_fit2[ind_of_1:100] - 0.1))]


plot(rhom1_seq, TVD_NegBinom_Geom_HMM_fit2, xlab = "1/rho", ylab = "Geom - NB TVD State 2", type = "l", lwd = 3)
abline(v = rhom1_lower_2, lwd = 3, lty = 2, col = "red")
abline(v = rhom1_upper_2, lwd = 3, lty = 2, col = "red")
abline(h = 0.1, lwd = 1, col = "grey")

#tau_set_2 <- optimise(f = function(tau){abs(integrate(f = function(phi){dpMOM_phi(phi, tau, sigma2 = 1)}, lower = rhom1_lower_2, upper = rhom1_upper_2)$value - 0.01)}, lower = 0.01, upper = 10)
tau_set_2 <- optimise(f = function(tau){abs(integrate(f = function(phi){dpeMOM_phi(phi, tau, sigma2 = 1)}, lower = rhom1_lower_2, upper = rhom1_upper_2)$value - 0.01)}, lower = 0.01, upper = 10)

phim1_seq <- seq(0, 5, length.out = 1000)
#plot(phim1_seq, dpMOM_phi(phim1_seq, tau = tau_set_2$minimum, sigma2 = 1), lwd = 3, type = "l", xlab = "1/phi", ylab = "pi(1/phi)", main = "NLP 1/phi - state 2")
plot(phim1_seq, dpeMOM_phi(phim1_seq, tau = tau_set_2$minimum, sigma2 = 1), lwd = 3, type = "l", xlab = "1/phi", ylab = "pi(1/phi)", main = "NLP 1/phi - state 2")
abline(v = rhom1_lower_2, lwd = 3, lty = 2, col = "red")
abline(v = rhom1_upper_2, lwd = 3, lty = 2, col = "red")
points(phim1_seq, dinvgamma(phim1_seq, shape = 2, scale = 3), lwd = 3, lty = 2, type = "l")
points(phim1_seq, dgamma(phim1_seq, shape = 3, rate = 2), lwd = 3, lty = 2, type = "l", col = "blue")

## State 3

p_3 <- apply(VARHMM_l1ball_params$gamma, c(2, 3), mean)[3, 3]

TVD_NegBinom_Geom_HMM_fit3 <- rep(NA, 100)
for(i in 1:100){
  TVD_NegBinom_Geom_HMM_fit3[i] <- TVD_NegBinom_Geom_rhom1(p = p_3, rhom1 = rhom1_seq[i], x_thresh = 1000)
}

rhom1_lower_3 <- rhom1_seq[which.min(abs(TVD_NegBinom_Geom_HMM_fit3[1:ind_of_1] - 0.1))]
rhom1_upper_3 <- rhom1_seq[(ind_of_1 - 1) + which.min(abs(TVD_NegBinom_Geom_HMM_fit3[ind_of_1:100] - 0.1))]

plot(rhom1_seq, TVD_NegBinom_Geom_HMM_fit3, xlab = "1/rho", ylab = "Geom - NB TVD State 3", type = "l", lwd = 3)
abline(v = rhom1_lower_3, lwd = 3, lty = 2, col = "red")
abline(v = rhom1_upper_3, lwd = 3, lty = 2, col = "red")
abline(h = 0.1, lwd = 1, col = "grey")

#tau_set_3 <- optimise(f = function(tau){abs(integrate(f = function(phi){dpMOM_phi(phi, tau, sigma2 = 1)}, lower = rhom1_lower_3, upper = rhom1_upper_3)$value - 0.01)}, lower = 0.01, upper = 10)
tau_set_3 <- optimise(f = function(tau){abs(integrate(f = function(phi){dpeMOM_phi(phi, tau, sigma2 = 1)}, lower = rhom1_lower_3, upper = rhom1_upper_3)$value - 0.01)}, lower = 0.01, upper = 10)

phim1_seq <- seq(0, 5, length.out = 1000)
#plot(phim1_seq, dpMOM_phi(phim1_seq, tau = tau_set_3$minimum, sigma2 = 1), lwd = 3, type = "l", xlab = "1/phi", ylab = "pi(1/phi)", main = "NLP 1/phi - state 3")
plot(phim1_seq, dpeMOM_phi(phim1_seq, tau = tau_set_3$minimum, sigma2 = 1), lwd = 3, type = "l", xlab = "1/phi", ylab = "pi(1/phi)", main = "NLP 1/phi - state 3")
abline(v = rhom1_lower_3, lwd = 3, lty = 2, col = "red")
abline(v = rhom1_upper_3, lwd = 3, lty = 2, col = "red")
points(phim1_seq, dinvgamma(phim1_seq, shape = 2, scale = 1), lwd = 3, lty = 2, type = "l")
points(phim1_seq, dgamma(phim1_seq, shape = 3, rate = 2), lwd = 3, lty = 2, type = "l", col = "blue")
```

```{r NLP_prior, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

tau_set_1

tau_set_2

tau_set_3

```

## Prior Specification

```{r NBapproxVARHSMM_NLP_prior_specification, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

a_0 <- c(a_01, a_02, a_03)
b_0 <- c(b_01, b_02, b_03)

alpha_0 <- matrix(c(alpha_1[-1], alpha_2[-2], alpha_3[-3]), nrow = K, ncol = K-1, byrow = TRUE)

tau_phi <- c(tau_set_1$minimum, tau_set_2$minimum, tau_set_3$minimum) 
sigma2_phi <- c(1, 1, 1)

```



## MCMC

```{r NBapproxVARHSMM_l1ball_NLP_fit, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

# data
NBapproxVARHSMM_l1ball_NLP_data <- list(N = N, D = D, K = K, 
                   P = P, y = obs, 
                   m = m,
                   beta_0_loc = matrix(0, K, D), 
                   beta_0_scale = lambda_beta_set, 
                   beta_loc = 0, beta_scale = lambda_beta_set,
                   tau_loc = tau_loc, tau_scale = tau_scale, 
                   Omega_shape = Omega_shape,
                   r_alpha = alpha_r_set,
                   a_0_lambda = a_0, 
                   b_0_lambda = b_0, 
                   tau_phi = tau_phi, 
                   sigma2_phi = sigma2_phi, 
                   alpha_0 = alpha_0)

# init
NBapproxVARHSMM_NLP_init <- list(
  gamma = apply(NBapproxVARHSMM_l1ball_params$gamma, c(2, 3), mean),
  tilde_p = colMeans(NBapproxVARHSMM_l1ball_params$tilde_p),
  tilde_phim1 = colMeans(NBapproxVARHSMM_l1ball_params$tilde_phim1),
  beta_0 = apply(NBapproxVARHSMM_l1ball_params$beta_0, c(2, 3), mean),
  tilde_beta = apply(NBapproxVARHSMM_l1ball_params$tilde_beta, c(2, 3), mean),
  tau = apply(NBapproxVARHSMM_l1ball_params$tau, c(2, 3), mean),
  L_Omega = apply(NBapproxVARHSMM_l1ball_params$L_Omega, c(2, 3, 4), mean),
  tilde_ray = colMeans(NBapproxVARHSMM_l1ball_params$tilde_ray)
  )

# fit 
NBapproxVARHSMM_l1ball_NLP_fit <- sampling(
                       #object = NBapproxVARHSMM_l1ball_NLP_stan,
                       object = NBapproxVARHSMM_sparse_l1ball_NLP_stan,
                       data = NBapproxVARHSMM_l1ball_NLP_data, seed = 123, 
                       chains = 1, iter = 1000 + N_MCMC, 
                       init = list(c1 = NBapproxVARHSMM_NLP_init),
                       warmup = 1000)


NBapproxVARHSMM_l1ball_NLP_params <- rstan::extract(NBapproxVARHSMM_l1ball_NLP_fit)

get_elapsed_time(NBapproxVARHSMM_l1ball_NLP_fit)

NBapproxVARHSMM_l1ball_NLP_bridge <- bridge_sampler(NBapproxVARHSMM_l1ball_NLP_fit, silent = TRUE)


```

saving to RData

```{r NBapproxVARHSMM_l1ball_NLP_fit_save, include=TRUE,echo=TRUE, eval = FALSE,  cache=FALSE}

save(NBapproxVARHSMM_l1ball_NLP_fit, NBapproxVARHSMM_l1ball_NLP_bridge, file = "NBapproxVARHSMM_l1ball_NLP_fit_simulation.RData")

```

## Chain Diag

```{r NBapproxVARHSMM_l1ball_NLP_diag, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

fit_summary <- summary(NBapproxVARHSMM_l1ball_NLP_fit)
#cbind(fit_summary$summary[,3], fit_summary$summary[,9])

mean(fit_summary$summary[1:(K*K + 2*K*D + K*D^2 + K*D*D*P + K),9], na.rm = TRUE)

traceplot(NBapproxVARHSMM_l1ball_NLP_fit, pars = c("ray[1]", "ray[2]", "ray[3]", "lp__"))
```

## Posterior Predictive 

```{r NBapprox_VAR_HSMM_l1ball_NLP_posterior_predictive_rn, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}


NBapprox_VAR_HSMM_NLP_predictive <- NBapproxVARHSMM_getPredictive(NBapproxVARHSMM_l1ball_NLP_fit , m, obs, 
                                                  pseudo = FALSE, 
                                                  L1_ball = TRUE, ndraw = 50)
```

```{r NBapprox_VAR_HSMM_l1ball_NLP_posterior_predictive, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}
p_hat <- NBapprox_VAR_HSMM_NLP_predictive$log_pred_density
z_hat <- NBapprox_VAR_HSMM_NLP_predictive$z_hat
y_hat <- NBapprox_VAR_HSMM_NLP_predictive$y_hat

# plot posterior predictive
K <- dim(rstan::extract(NBapproxVARHSMM_l1ball_NLP_fit)$beta_0)[2]
plotPosteriorPredictive(obs, y_hat, z_hat, K)

state[1:20]
z_hat[1:20]
## this is a vector the length of the states saying which estimated states corresponds to the which real state - then below I keep the dat agenerating as it is and repce by state_corresponce indexes
true_state_order <- c(1, 2, 3)
estimated_state_order_HSMM_NLP <- c(1, 2, 3)
state_correspondence <- true_state_order[estimated_state_order_HSMM_NLP]

NBapproxVARHSMM_l1ball_NLP_state_errors <- sum(abs(state != state_correspondence[z_hat]))
NBapproxVARHSMM_l1ball_NLP_state_errors

NBapproxVARHSMM_l1ball_NLP_state_errors/N

NBapproxVARHSMM_l1ball_NLP_llh <- sum(p_hat)
NBapproxVARHSMM_l1ball_NLP_llh

NBapproxVARHSMM_l1ball_llh
VARHMM_l1ball_llh

```

## State Probabilities

```{r NBapproxVARHSMM_l1ball_NLP_state_probabilities, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

par(mfrow = c(2, 1))
plotPosteriorPredictive(obs, y_hat, z_hat, K)
NBapproxVARHSMM_plotStateProbs(NBapproxVARHSMM_l1ball_NLP_fit, obs, m = m, pseudo = FALSE, L1_ball = TRUE)

NBapproxVARHSMM_NLP_plotStateProbs_state_probs <- NBapproxVARHSMM_stateProbs(NBapproxVARHSMM_l1ball_NLP_params, obs, m = m, pseudo = FALSE, L1_ball = TRUE)

simul$state_phase <- c("State 1", "State 2", "State 3")[estimated_state_order_HSMM_NLP[simul$state]]

par(mfrow = c(1, 1))
simulation_plot(simul, plt_all = TRUE, plt_univ = FALSE)


```



```{r NBapproxVARHSMM_l1ball_NLP_state_probabilities_tikz, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE, fig.height = 1.5, fig.width = 5, dev = "tikz"}

par(mar = c(3.1, 3.3, 1.5, 1.1))  # bottom, left, top, right
#par(mar = c(5.1, 4.1, 4.1, 2.1)) # Default
#par(mgp = c(3, 1, 0)) # Default - location of xlab and ylab, tick-mark labels, tick marks.
par(mgp = c(2.15, 1, 0))
par(cex.lab = 1.00, cex.axis = 1.00, cex.main = 1.00)


NBapproxVARHSMM_plotStateProbs(NBapproxVARHSMM_l1ball_NLP_fit, obs, m = m, pseudo = FALSE, L1_ball = TRUE)



```

## Breir Score Selection (state estimation)

```{r NBapproxVARHSMM_l1ball_NLP_state_probabilities_BreirScore, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

m_temp <- c(0, cumsum(m))

NBapproxVARHSMM_l1ball_NLP_breir_score <- sum((colSums(NBapproxVARHSMM_NLP_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM_NLP[1]] + 1):m_temp[estimated_state_order_HSMM_NLP[1]+1],]) - (state == 1))^2)/(N) + sum((colSums(NBapproxVARHSMM_NLP_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM_NLP[2]] + 1):m_temp[estimated_state_order_HSMM_NLP[2]+1],]) - (state == 2))^2)/(N) + sum((colSums(NBapproxVARHSMM_NLP_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM_NLP[3]] + 1):m_temp[estimated_state_order_HSMM_NLP[3]+1],]) - (state == 3))^2)/(N)

NBapproxVARHSMM_l1ball_NLP_breir_score
```

## VAR coefficients

```{r NBapproxVARHSMM_l1ball_NLP_VAR_params, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

theta_sims <- get_theta_sims(NBapproxVARHSMM_l1ball_NLP_params)

# posterior estimate beta (projected)
beta_est <- get_beta_est(NBapproxVARHSMM_l1ball_NLP_params, L1_ball = TRUE, mat = TRUE)

simul$state[1:20]
state_correspondence[NBapprox_VAR_HSMM_predictive$z_hat[1:20]]

beta_est[estimated_state_order_HSMM_NLP[1], , ,]; parms_true$beta[[1]]
beta_est[estimated_state_order_HSMM_NLP[2], , ,]; parms_true$beta[[2]]
beta_est[estimated_state_order_HSMM_NLP[3], , ,]; parms_true$beta[[3]]

sum(abs(beta_est[estimated_state_order_HSMM_NLP[1], , ,] - drop(parms_true$beta[[1]])))
sum(abs(beta_est[estimated_state_order_HSMM_NLP[2], , ,] - drop(parms_true$beta[[2]])))
sum(abs(beta_est[estimated_state_order_HSMM_NLP[3], , ,] - drop(parms_true$beta[[3]])))

NBapproxVARHSMM_l1ball_NLP_beta1_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HSMM_NLP[1], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[1]])))
NBapproxVARHSMM_l1ball_NLP_beta1_MSE

NBapproxVARHSMM_l1ball_NLP_beta2_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HSMM_NLP[2], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[2]])))
NBapproxVARHSMM_l1ball_NLP_beta2_MSE

NBapproxVARHSMM_l1ball_NLP_beta3_MSE <- sum(abs(drop(beta_unstandardise(beta_est[estimated_state_order_HSMM_NLP[3], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[3]])))
NBapproxVARHSMM_l1ball_NLP_beta3_MSE
```

### Inclusion Probabilities

```{r NBapproxVARHSMM_l1ball_NLP_Inclusion_probabilities_params, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

# - inclusion probabilities 
p_est <- get_inclusion_sims(NBapproxVARHSMM_l1ball_NLP_params, p_est = TRUE)$p_est
p_est[estimated_state_order_HSMM_NLP[1], , , 1]; parms_true$beta[[1]]
p_est[estimated_state_order_HSMM_NLP[2], , , 1]; parms_true$beta[[2]]
p_est[estimated_state_order_HSMM_NLP[3], , , 1]; parms_true$beta[[3]]


par(mfrow = c(1, 2))
plot.heat(Matrix = parms_true$beta[[1]][,,1], Xlab="", Ylab="", Main="Generating $\\theta_1^{(1)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[1], , , 1], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_1^{(1)}$", limit=c(0,1))

par(mfrow = c(1, 2))
plot.heat(Matrix = parms_true$beta[[1]][,,2], Xlab="", Ylab="", Main="Generating $\\theta_1^{(1)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[1], , , 2], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_2^{(1)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[2]][,,1], Xlab="", Ylab="", Main="Generating $\\theta_1^{(2)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[2], , , 1], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_1^{(2)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[2]][,,2], Xlab="", Ylab="", Main="Generating $\\theta_2^{(2)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[2], , , 2], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_2^{(2)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[3]][,,1], Xlab="", Ylab="", Main="Generating $\\theta_1^{(3)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[3], , , 1], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_1^{(3)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[3]][,,2], Xlab="", Ylab="", Main="Generating $\\theta_2^{(3)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[3], , , 2], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_2^{(3)}$", limit=c(0,1))

```

```{r NBapproxVARHSMM_l1ball_NLP_Inclusion_probabilities_params_tikz, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE, fig.height = 3, fig.width = 3.5, dev = "tikz"}

par(mar = c(3.1, 3.3, 1.5, 1.1))  # bottom, left, top, right
#par(mar = c(5.1, 4.1, 4.1, 2.1)) # Default
#par(mgp = c(3, 1, 0)) # Default - location of xlab and ylab, tick-mark labels, tick marks.
par(mgp = c(2.15, 1, 0))
par(cex.lab = 1.25, cex.axis = 1.25, cex.main = 1.25)


plot.heat(Matrix = parms_true$beta[[1]][,,1], Xlab="", Ylab="", Main="Generating $\\theta_1^{(1)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[1], , , 1], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_1^{(1)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[1]][,,2], Xlab="", Ylab="", Main="Generating $\\theta_2^{(1)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[1], , , 2], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_2^{(1)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[2]][,,1], Xlab="", Ylab="", Main="Generating $\\theta_1^{(2)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[2], , , 1], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_1^{(2)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[2]][,,2], Xlab="", Ylab="", Main="Generating $\\theta_2^{(2)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[2], , , 2], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_2^{(2)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[3]][,,1], Xlab="", Ylab="", Main="Generating $\\theta_1^{(3)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[3], , , 1], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_1^{(3)}$", limit=c(0,1))

plot.heat(Matrix = parms_true$beta[[3]][,,2], Xlab="", Ylab="", Main="Generating $\\theta_2^{(3)}$", limit=c(-1,1))
plot.heat(Matrix = p_est[estimated_state_order_HSMM_NLP[3], , , 2], Xlab="", Ylab="", Main="Estimated $\\mathbb{P}_2^{(3)}$", limit=c(0,1))

```

### Breir Score Selection (parameter estimation)

```{r NBapproxVARHSMM_l1ball_NLP_Breir_Score_Selection, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

parms_true_beta <- array(NA, dim = c(K, D, D, P))
parms_true_beta[estimated_state_order_HSMM_NLP[1], , ,] <- parms_true$beta[[1]]
parms_true_beta[estimated_state_order_HSMM_NLP[2], , ,] <- parms_true$beta[[2]]
parms_true_beta[estimated_state_order_HSMM_NLP[3], , ,] <- parms_true$beta[[3]]

NBapproxVARHSMM_l1ball_NLP_breir_score_beta <- sum((p_est - (parms_true_beta != 0))^2)/(K*D*D*P)
NBapproxVARHSMM_l1ball_NLP_breir_score_beta


```


## Covariance Estimation

Plot cov2cors, the standardisation only acted marginally so should leave the correlations in tact

```{r NBapproxVARHSMM_l1ball_NLP_cov_params, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

### Sigma 
# - covariance matricies
Sigma_est <- list()
for (k in 1:K) {
  Sigma.sims <- array(NA, dim = c(N_MCMC, D, D))# where is K in here?
  for (tt in 1:N_MCMC) {
    Omega <- NBapproxVARHSMM_l1ball_NLP_params$L_Omega[tt, k, ,] %*% t(NBapproxVARHSMM_l1ball_NLP_params$L_Omega[tt, k, ,])
    tau <- NBapproxVARHSMM_l1ball_NLP_params$tau[tt, k, ]
    Sigma.sims[tt, ,] <- quad_form_diag(Omega, tau)
  }
  Sigma_est[[k]] <- apply(Sigma.sims, c(2, 3), mean)
}; Sigma_est; 

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP[1]]]), Xlab="", Ylab="", Main="Estimated $\\Omega^{(1)}$", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[1]]), Xlab="", Ylab="", Main="Generated $\\Omega^{(1)}$", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP[2]]]), Xlab="", Ylab="", Main="Estimated $\\Omega^{(2)}$", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[2]]), Xlab="", Ylab="", Main="Generated $\\Omega^{(2)}$", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP[3]]]), Xlab="", Ylab="", Main="Estimated $\\Omega^{(3)}$", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[3]]), Xlab="", Ylab="", Main="Generated $\\Omega^{(3)}$", limit=c(-1,1))
```

```{r NBapproxVARHSMM_l1ball_NLP_cov_params_tikz, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE, fig.height = 3, fig.width = 3.5, dev = "tikz"}

par(mar = c(3.1, 3.3, 1.5, 1.1))  # bottom, left, top, right
#par(mar = c(5.1, 4.1, 4.1, 2.1)) # Default
#par(mgp = c(3, 1, 0)) # Default - location of xlab and ylab, tick-mark labels, tick marks.
par(mgp = c(2.15, 1, 0))
par(cex.lab = 1.25, cex.axis = 1.25, cex.main = 1.25)

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP[1]]]), Xlab="", Ylab="", Main="Estimated $\\Omega^{(1)}$", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[1]]), Xlab="", Ylab="", Main="Generated $\\Omega^{(1)}$", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP[2]]]), Xlab="", Ylab="", Main="Estimated $\\Omega^{(2)}$", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[2]]), Xlab="", Ylab="", Main="Generated $\\Omega^{(2)}$", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP[3]]]), Xlab="", Ylab="", Main="Estimated $\\Omega^{(3)}$", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[3]]), Xlab="", Ylab="", Main="Generated $\\Omega^{(3)}$", limit=c(-1,1))
```

## Dwell Parameters

```{r NBapproxVARHSMM_l1ball_NLP_dwell_parameters, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

colMeans(NBapproxVARHSMM_l1ball_NLP_params$lambda)[estimated_state_order_HSMM_NLP]
colMeans(NBapproxVARHSMM_l1ball_params$lambda)[estimated_state_order_HSMM]

parms_true$lambda

mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[1],estimated_state_order_HMM[1]]))
mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[2],estimated_state_order_HMM[2]]))
mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[3],estimated_state_order_HMM[3]]))

colMeans(1/NBapproxVARHSMM_l1ball_NLP_params$phim1)[estimated_state_order_HSMM_NLP]
colMeans(1/NBapproxVARHSMM_l1ball_params$phim1)[estimated_state_order_HSMM]

parms_true$phi


plot(density(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[1]]), xlab = "phi^{-1}", ylab = "Density", lwd = 3, xlim = c(0, 10))
lines(density(NBapproxVARHSMM_l1ball_params$phim1[,estimated_state_order_HSMM[1]]), lwd = 3, lty = 2)
abline(v = 1, lwd = 3, lty = 2, col = "red")

plot(density(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[2]]), xlab = "phi^{-1}", ylab = "Density", lwd = 3, xlim = c(0, 10))
lines(density(NBapproxVARHSMM_l1ball_params$phim1[,estimated_state_order_HSMM[2]]), lwd = 3, lty = 2)
abline(v = 1, lwd = 3, lty = 2, col = "red")

plot(density(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[3]]), xlab = "phi^{-1}", ylab = "Density", lwd = 3, xlim = c(0, 10))
lines(density(NBapproxVARHSMM_l1ball_params$phim1[,estimated_state_order_HSMM[3]]), lwd = 3, lty = 2)
abline(v = 1, lwd = 3, lty = 2, col = "red")

hist(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[1]], probability = TRUE, xlab = "phi^{-1}", ylab = "Density", xlim = c(0, 10), breaks = 300)
abline(v = 1, lwd = 3, lty = 2, col = "red")
hist(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[2]], probability = TRUE, xlab = "phi^{-1}", ylab = "Density", xlim = c(0, 10), breaks = 300)
abline(v = 1, lwd = 3, lty = 2, col = "red")
hist(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[3]], probability = TRUE, xlab = "phi^{-1}", ylab = "Density", xlim = c(0, 10), breaks = 300)
abline(v = 1, lwd = 3, lty = 2, col = "red")

NBapproxVARHSMM_l1ball_NLP_bridge$logml
NBapproxVARHSMM_l1ball_bridge$logml
VARHMM_l1ball_bridge$logml
```

## Plotting the dwell distribution 

```{r Dwell_distributions_predictives, include=TRUE,echo=TRUE, eval=TRUE, cache=FALSE}
NegBinom_dwell_approx <- function(r, lambda, phi, m){
  return(
    as.numeric((r <= m))*dnbinom(r-1, mu = lambda, size = phi) + 
      as.numeric(r > m)*dnbinom(m-1, mu = lambda, size = phi)*(1-c_hazard_NegBinom(m, lambda, phi))^(r-m))
}

## Predictive

N_MCMC <- 5000
## State 1
x_seq_1 <- 1:30
dwell_dgeom_1 <- rep(0, length(x_seq_1))
dwell_dnbimon_1 <- rep(0, length(x_seq_1))
dwell_dnbimon_approx_1 <- rep(0, length(x_seq_1))
for(j in 1:N_MCMC){
  p_1 <- 1 - VARHMM_l1ball_params$gamma[j, estimated_state_order_HMM[1],estimated_state_order_HMM[1]]
  dwell_dgeom_1 <- dwell_dgeom_1 + dgeom(x_seq_1 - 1, prob = p_1)

  lambda_1 <- NBapproxVARHSMM_l1ball_NLP_params$lambda[j, estimated_state_order_HSMM[1]]
  phi_1 <- 1/NBapproxVARHSMM_l1ball_NLP_params$phim1[j, estimated_state_order_HSMM[1]]
  dwell_dnbimon_1 <- dwell_dnbimon_1 + dnbinom(x_seq_1 - 1, size = phi_1, mu = lambda_1)
  
  dwell_dnbimon_approx_1 <- dwell_dnbimon_approx_1 + NegBinom_dwell_approx(x_seq_1, lambda_1, phi_1, m[estimated_state_order_HSMM_NLP[1]])
  
}

plot(x_seq_1, dwell_dgeom_1/N_MCMC, type = "l", lwd = 3, xlab = "Dwell time", ylab = "Density", col = "black", main = "")
points(x_seq_1, dwell_dnbimon_1/N_MCMC , type = "l", lwd = 3, col = "grey")
points(x_seq_1, dwell_dnbimon_approx_1/N_MCMC , type = "l", lwd = 3, col = "dark grey", lty = 2)
legend("topright", c("Geometric", "Negative Binomial (EXACT)", "Negative Binomial (APPROX)"), col= c("black", "grey", "dark grey"), lwd = rep(5, 3), lty = c(1, 1, 2), bty = "n", cex = 1.0)

## State 2
x_seq_2 <- 1:30
dwell_dgeom_2 <- rep(0, length(x_seq_2))
dwell_dnbimon_2 <- rep(0, length(x_seq_2))
dwell_dnbimon_approx_2 <- rep(0, length(x_seq_2))
for(j in 1:N_MCMC){
  p_2 <- 1 - VARHMM_l1ball_params$gamma[j, estimated_state_order_HMM[2],estimated_state_order_HMM[2]]
  dwell_dgeom_2 <- dwell_dgeom_2 + dgeom(x_seq_2 - 1, prob = p_2)

  lambda_2 <- NBapproxVARHSMM_l1ball_NLP_params$lambda[j, estimated_state_order_HSMM[2]]
  phi_2 <- 1/NBapproxVARHSMM_l1ball_NLP_params$phim1[j, estimated_state_order_HSMM[2]]
  dwell_dnbimon_2 <- dwell_dnbimon_2 + dnbinom(x_seq_2 - 1, size = phi_2, mu = lambda_2)
  
  dwell_dnbimon_approx_2 <- dwell_dnbimon_approx_2 + NegBinom_dwell_approx(x_seq_2, lambda_2, phi_2, m[estimated_state_order_HSMM_NLP[2]])
  
}

plot(x_seq_2, dwell_dgeom_2/N_MCMC, type = "l", lwd = 3, xlab = "Dwell time", ylab = "Density", col = "black", main = "")
points(x_seq_2, dwell_dnbimon_2/N_MCMC , type = "l", lwd = 3, col = "grey")
points(x_seq_2, dwell_dnbimon_approx_2/N_MCMC , type = "l", lwd = 3, col = "dark grey", lty = 2)
legend("topright", c("Geometric", "Negative Binomial (EXACT)", "Negative Binomial (APPROX)"), col= c("black", "grey", "dark grey"), lwd = rep(5, 3), lty = c(1, 1, 2), bty = "n", cex = 1.0)

## State 3
x_seq_3 <- 1:30
dwell_dgeom_3 <- rep(0, length(x_seq_3))
dwell_dnbimon_3 <- rep(0, length(x_seq_3))
dwell_dnbimon_approx_3 <- rep(0, length(x_seq_3))
for(j in 1:N_MCMC){
  p_3 <- 1 - VARHMM_l1ball_params$gamma[j, estimated_state_order_HMM[3],estimated_state_order_HMM[3]]
  dwell_dgeom_3 <- dwell_dgeom_3 + dgeom(x_seq_3 - 1, prob = p_3)

  lambda_3 <- NBapproxVARHSMM_l1ball_NLP_params$lambda[j, estimated_state_order_HSMM[3]]
  phi_3 <- 1/NBapproxVARHSMM_l1ball_NLP_params$phim1[j, estimated_state_order_HSMM[3]]
  dwell_dnbimon_3 <- dwell_dnbimon_3 + dnbinom(x_seq_3 - 1, size = phi_3, mu = lambda_3)
  
  dwell_dnbimon_approx_3 <- dwell_dnbimon_approx_3 + NegBinom_dwell_approx(x_seq_3, lambda_3, phi_3, m[estimated_state_order_HSMM_NLP[3]])
  
}

plot(x_seq_3, dwell_dgeom_3/N_MCMC, type = "l", lwd = 3, xlab = "Dwell time", ylab = "Density", col = "black", main = "")
points(x_seq_3, dwell_dnbimon_3/N_MCMC , type = "l", lwd = 3, col = "grey")
points(x_seq_3, dwell_dnbimon_approx_3/N_MCMC , type = "l", lwd = 3, col = "dark grey", lty = 2)
legend("topright", c("Geometric", "Negative Binomial (EXACT)", "Negative Binomial (APPROX)"), col= c("black", "grey", "dark grey"), lwd = rep(5, 3), lty = c(1, 1, 2), bty = "n", cex = 1.0)

```

```{r Dwell_distributions_predictives_tikz, include=TRUE,echo=TRUE, eval=TRUE, cache=FALSE, fig.height = 3, fig.width = 5, dev = "tikz"}

par(mar = c(3.1, 3.3, 1.5, 1.1))  # bottom, left, top, right
#par(mar = c(5.1, 4.1, 4.1, 2.1)) # Default
#par(mgp = c(3, 1, 0)) # Default - location of xlab and ylab, tick-mark labels, tick marks.
par(mgp = c(2.15, 1, 0))
par(cex.lab = 1.25, cex.axis = 1.25, cex.main = 1.25)

## Predictive

## State 1

plot(x_seq_1, dwell_dgeom_1/N_MCMC, type = "l", lwd = 3, xlab = "State 1 dwell time", ylab = "Density", col = "black", main = "")
points(x_seq_1, dwell_dnbimon_1/N_MCMC , type = "l", lwd = 3, col = "grey")
points(x_seq_1, dwell_dnbimon_approx_1/N_MCMC , type = "l", lwd = 3, col = "dark grey", lty = 2)
legend("topright", c("Geometric", "Negative Binomial (EXACT)", "Negative Binomial (APPROX)"), col= c("black", "grey", "dark grey"), lwd = rep(5, 3), lty = c(1, 1, 2), bty = "n", cex = 1.25)

## State 2

plot(x_seq_2, dwell_dgeom_2/N_MCMC, type = "l", lwd = 3, xlab = "State 2 dwell time", ylab = "Density", col = "black", main = "")
points(x_seq_2, dwell_dnbimon_2/N_MCMC , type = "l", lwd = 3, col = "grey")
points(x_seq_2, dwell_dnbimon_approx_2/N_MCMC , type = "l", lwd = 3, col = "dark grey", lty = 2)
#legend("topright", c("Geometric", "Negative Binomial (EXACT)", "Negative Binomial (APPROX)"), col= c("black", "grey", "dark grey"), lwd = rep(5, 3), lty = c(1, 1, 2), bty = "n", cex = 1.25)

## State 3


plot(x_seq_3, dwell_dgeom_3/N_MCMC, type = "l", lwd = 3, xlab = "State 3 dwell time", ylab = "Density", col = "black", main = "")
points(x_seq_3, dwell_dnbimon_3/N_MCMC , type = "l", lwd = 3, col = "grey")
points(x_seq_3, dwell_dnbimon_approx_3/N_MCMC , type = "l", lwd = 3, col = "dark grey", lty = 2)
#legend("topright", c("Geometric", "Negative Binomial (EXACT)", "Negative Binomial (APPROX)"), col= c("black", "grey", "dark grey"), lwd = rep(5, 3), lty = c(1, 1, 2), bty = "n", cex = 1.25)

```

# VAR-HSMM Negative Binomial - NLP - no $l_1$-ball {.tabset}

To see how the $l_1$-ball improves the state estimation 

## Model settings

```{r NBapproxVARHSMM_nol1_NLP_model_settings, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

N_MCMC <- 5000
K <- 3
P <- 2

m <- c(15, 15, 15)

```

## Prior Specification

```{r NBapproxVARHSMM_nol1_NLP_prior_specification, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

a_0 <- c(a_01, a_02, a_03)
b_0 <- c(b_01, b_02, b_03)

alpha_0 <- matrix(c(alpha_1[-1], alpha_2[-2], alpha_3[-3]), nrow = K, ncol = K-1, byrow = TRUE)

tau_phi <- c(tau_set_1$minimum, tau_set_2$minimum, tau_set_3$minimum) 
sigma2_phi <- c(1, 1, 1)

```

## VAR Coefficients (no l1-ball)

```{r prior_specification_beta_sparsity_nol1, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

prob_stable <- 0.95
N_MC <- 5000

P <- 2

## Setting lamabda ##

lambda_vec <- seq(0.01, 0.3, length.out = 20)
non_sparse_VAR_DExp_stability_prob_eval <- rep(NA, 20)

for(j in 1:20){
  non_sparse_VAR_DExp_stability_prob_eval[j] <- mean(non_sparse_VAR_DExp_stability_prob(N_MC, D, P, lambda = lambda_vec[j])  == 1)
  cat("lambda", j, "done", "\n")
}

lambda_beta_set_non_sparse <- lambda_vec[which.min(abs(non_sparse_VAR_DExp_stability_prob_eval - prob_stable))]


```

## MCMC

```{r NBapproxVARHSMM_NLP_fit, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}

# data
NBapproxVARHSMM_NLP_data <- list(N = N, D = D, K = K, 
                   P = P, y = obs, 
                   m = m,
                   beta_0_loc = matrix(0, K, D), 
                   beta_0_scale = lambda_beta_set_non_sparse, 
                   beta_loc = 0, beta_scale = lambda_beta_set_non_sparse,
                   tau_loc = tau_loc, tau_scale = tau_scale, 
                   Omega_shape = Omega_shape,
                   a_0_lambda = a_0, 
                   b_0_lambda = b_0, 
                   tau_phi = tau_phi, 
                   sigma2_phi = sigma2_phi, 
                   alpha_0 = alpha_0)

beta_init_nol1 <- matrix(NA, nrow = K, ncol = D*D*P)
for(k in 1:K){
  beta_init_nol1[k,] <- l1_ball_projection(apply(NBapproxVARHSMM_l1ball_params$beta[,k,], c(2), mean), NBapproxVARHSMM_l1ball_params$ray[k])
}

# init
NBapproxVARHSMM_NLP_nol1_init <- list(
  gamma = apply(NBapproxVARHSMM_l1ball_params$gamma, c(2, 3), mean),
  tilde_p = colMeans(NBapproxVARHSMM_l1ball_params$tilde_p),
  tilde_phim1 = colMeans(NBapproxVARHSMM_l1ball_params$tilde_phim1),
  beta_0 = apply(NBapproxVARHSMM_l1ball_params$beta_0, c(2, 3), mean),
  #beta = apply(NBapproxVARHSMM_l1ball_params$theta, c(2, 3), mean),
  beta = beta_init_nol1,
  tau = apply(NBapproxVARHSMM_l1ball_params$tau, c(2, 3), mean),
  L_Omega = apply(NBapproxVARHSMM_l1ball_params$L_Omega, c(2, 3, 4), mean)
  )

# fit 
#NBapproxVARHSMM_NLP_fit <- sampling(object = NBapproxVARHSMM_NLP_stan,
NBapproxVARHSMM_NLP_fit <- sampling(object = NBapproxVARHSMM_sparse_NLP_stan,
                       data = NBapproxVARHSMM_NLP_data, seed = 123, 
                       chains = 1, iter = 1000 + N_MCMC, 
                       init = list(c1 = NBapproxVARHSMM_NLP_nol1_init),
                       warmup = 1000)


NBapproxVARHSMM_NLP_params <- rstan::extract(NBapproxVARHSMM_NLP_fit)

get_elapsed_time(NBapproxVARHSMM_NLP_fit)

NBapproxVARHSMM_NLP_bridge <- bridge_sampler(NBapproxVARHSMM_NLP_fit, silent = TRUE)
```

saving to RData

```{r NBapproxVARHSMM_NLP_fit_save, include=TRUE,echo=TRUE, eval = FALSE,  cache=FALSE}

save(NBapproxVARHSMM_NLP_fit, NBapproxVARHSMM_NLP_bridge, file = "NBapproxVARHSMM_NLP_fit_simulation.RData")

```

## Chain Diag

```{r NBapproxVARHSMM_NLP_diag, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

fit_summary <- summary(NBapproxVARHSMM_l1ball_NLP_fit)
#cbind(fit_summary$summary[,3], fit_summary$summary[,9])

mean(fit_summary$summary[1:(K*K + 2*K*D + K*D^2 + K*D*D*P + K),9], na.rm = TRUE)

traceplot(NBapproxVARHSMM_NLP_fit, pars = c("lp__"))
```

## Posterior Predictive 

```{r NBapprox_VAR_HSMM_NLP_posterior_predictive_rn, include=TRUE,echo=TRUE, eval = TRUE,  cache=TRUE}


NBapprox_VAR_HSMM_NLP_predictive <- NBapproxVARHSMM_getPredictive(NBapproxVARHSMM_NLP_fit , m, obs, 
                                                  pseudo = FALSE, 
                                                  L1_ball = FALSE, ndraw = 50)
```

```{r NBapprox_VAR_HSMM_NLP_posterior_predictive, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}
p_hat <- NBapprox_VAR_HSMM_NLP_predictive$log_pred_density
z_hat <- NBapprox_VAR_HSMM_NLP_predictive$z_hat
y_hat <- NBapprox_VAR_HSMM_NLP_predictive$y_hat

# plot posterior predictive
K <- dim(rstan::extract(NBapproxVARHSMM_NLP_fit)$beta_0)[2]
plotPosteriorPredictive(obs, y_hat, z_hat, K)

state[1:20]
z_hat[1:20]
## this is a vector the length of the states saying which estimated states corresponds to the which real state - then below I keep the dat agenerating as it is and repce by state_corresponce indexes
true_state_order <- c(1, 2, 3)
estimated_state_order_HSMM_NLP_nol1 <- c(1, 2, 3)
state_correspondence <- true_state_order[estimated_state_order_HSMM_NLP_nol1]

NBapproxVARHSMM_NLP_state_errors <- sum(abs(state != state_correspondence[z_hat]))
NBapproxVARHSMM_NLP_state_errors

NBapproxVARHSMM_NLP_state_errors/N

NBapproxVARHSMM_NLP_llh <- sum(p_hat)
NBapproxVARHSMM_NLP_llh

NBapproxVARHSMM_l1ball_NLP_llh

NBapproxVARHSMM_l1ball_llh
VARHMM_l1ball_llh


```

## State Probabilities

```{r NBapproxVARHSMM_NLP_state_probabilities, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

par(mfrow = c(2, 1))

plotPosteriorPredictive(obs, y_hat, z_hat, K)
NBapproxVARHSMM_plotStateProbs(NBapproxVARHSMM_NLP_fit, obs, m = m, pseudo = FALSE, L1_ball = FALSE)

NBapproxVARHSMM_NLP_plotStateProbs_state_probs <- NBapproxVARHSMM_stateProbs(NBapproxVARHSMM_NLP_params, obs, m = m, pseudo = FALSE, L1_ball = FALSE)


```

## Breir Score Selection (state estimation)

```{r NBapproxVARHSMM_NLP_state_probabilities_BreirScore, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

m_temp <- c(0, cumsum(m))

NBapproxVARHSMM_NLP_breir_score <- sum((colSums(NBapproxVARHSMM_NLP_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM_NLP_nol1[1]] + 1):m_temp[estimated_state_order_HSMM_NLP_nol1[1]+1],]) - (state == 1))^2)/(N) + sum((colSums(NBapproxVARHSMM_NLP_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM_NLP_nol1[2]] + 1):m_temp[estimated_state_order_HSMM_NLP_nol1[2]+1],]) - (state == 2))^2)/(N) + sum((colSums(NBapproxVARHSMM_NLP_plotStateProbs_state_probs[(m_temp[estimated_state_order_HSMM_NLP_nol1[3]] + 1):m_temp[estimated_state_order_HSMM_NLP_nol1[3]+1],]) - (state == 3))^2)/(N)

NBapproxVARHSMM_NLP_breir_score
```

## VAR coefficients

```{r NBapproxVARHSMM_NLP_VAR, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}


# posterior estimate beta (projected)
beta_est_noSparsity <- get_beta_est(NBapproxVARHSMM_NLP_params, L1_ball = FALSE, mat = TRUE)

simul$state[1:20]
NBapprox_VAR_HSMM_NLP_predictive$z_hat[1:20]

beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[1], , ,]; parms_true$beta[[1]]
beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[2], , ,]; parms_true$beta[[2]]
beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[3], , ,]; parms_true$beta[[3]]


sum(abs(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[1], , ,] - drop(parms_true$beta[[1]])))
sum(abs(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[2], , ,] - drop(parms_true$beta[[2]])))
sum(abs(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[3], , ,] - drop(parms_true$beta[[3]])))

sum(abs(drop(beta_unstandardise(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[1], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[1]])))
sum(abs(drop(beta_unstandardise(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[2], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[2]])))
sum(abs(drop(beta_unstandardise(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[3], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[3]])))

NBapproxVARHSMM_NLP_beta1_MSE <- sum(abs(drop(beta_unstandardise(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[1], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[1]])))
NBapproxVARHSMM_NLP_beta1_MSE

NBapproxVARHSMM_NLP_beta2_MSE <- sum(abs(drop(beta_unstandardise(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[2], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[2]])))
NBapproxVARHSMM_NLP_beta2_MSE

NBapproxVARHSMM_NLP_beta3_MSE <- sum(abs(drop(beta_unstandardise(beta_est_noSparsity[estimated_state_order_HSMM_NLP_nol1[3], , ,], simul$col_m, simul$col_s)) - drop(parms_true$beta[[3]])))
NBapproxVARHSMM_NLP_beta3_MSE


```

## Breir Score (VAR estimations)

What was the breir score of having everything in the model

```{r NBapproxVARHSMM_NLP_VAR_breir_score, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}


NBapproxVARHSMM_NLP_breir_score_beta <- sum((1 - (parms_true_beta != 0))^2)/(K*D*D*P)
NBapproxVARHSMM_NLP_breir_score_beta

```


## Covariance Estimation

Plot cov2cors, the standardisation only acted marginally so should leave the correlations in tact

```{r NBapproxVARHSMM_NLP_cov_params, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

### Sigma 
# - covariance matricies
Sigma_est <- list()
for (k in 1:K) {
  Sigma.sims <- array(NA, dim = c(N_MCMC, D, D))# where is K in here?
  for (tt in 1:N_MCMC) {
    Omega <- NBapproxVARHSMM_NLP_params$L_Omega[tt, k, ,] %*% t(NBapproxVARHSMM_NLP_params$L_Omega[tt, k, ,])
    tau <- NBapproxVARHSMM_NLP_params$tau[tt, k, ]
    Sigma.sims[tt, ,] <- quad_form_diag(Omega, tau)
  }
  Sigma_est[[k]] <- apply(Sigma.sims, c(2, 3), mean)
}; Sigma_est; 

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP_nol1[1]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[1]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP_nol1[2]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[2]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))

plot.heat(Matrix = cov2cor(Sigma_est[[estimated_state_order_HSMM_NLP_nol1[3]]]), Xlab="", Ylab="", Main="Estimated Sigma", limit=c(-1,1))
plot.heat(Matrix = cov2cor(parms_true$Sigma[[3]]), Xlab="", Ylab="", Main="Generated Sigma", limit=c(-1,1))

```

## Dwell Parameters

```{r NBapproxVARHSMM_NLP_dwell_parameters, include=TRUE,echo=TRUE, eval = TRUE,  cache=FALSE}

colMeans(NBapproxVARHSMM_NLP_params$lambda)[estimated_state_order_HSMM_NLP_nol1]
colMeans(NBapproxVARHSMM_l1ball_NLP_params$lambda)[estimated_state_order_HSMM_NLP]
colMeans(NBapproxVARHSMM_l1ball_params$lambda)[estimated_state_order_HSMM]

parms_true$lambda

mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[1],estimated_state_order_HMM[1]]))
mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[2],estimated_state_order_HMM[2]]))
mean(1/(1 - VARHMM_l1ball_params$gamma[,estimated_state_order_HMM[3],estimated_state_order_HMM[3]]))

colMeans(1/NBapproxVARHSMM_NLP_params$phim1)[estimated_state_order_HSMM_NLP_nol1]
colMeans(1/NBapproxVARHSMM_l1ball_NLP_params$phim1)[estimated_state_order_HSMM_NLP]
colMeans(1/NBapproxVARHSMM_l1ball_params$phim1)[estimated_state_order_HSMM]

parms_true$phi


plot(density(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[1]]), xlab = "phi^{-1}", ylab = "Density", lwd = 3, xlim = c(0, 10))
lines(density(NBapproxVARHSMM_l1ball_params$phim1[,estimated_state_order_HSMM[1]]), lwd = 3, lty = 2)
abline(v = 1, lwd = 3, lty = 2, col = "red")
lines(density(NBapproxVARHSMM_NLP_params$phim1[,estimated_state_order_HSMM_NLP_nol1[1]]), lwd = 3, lty = 1, col = "grey")
abline(v = 1, lwd = 3, lty = 2, col = "red")

plot(density(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[2]]), xlab = "phi^{-1}", ylab = "Density", lwd = 3, xlim = c(0, 10))
lines(density(NBapproxVARHSMM_l1ball_params$phim1[,estimated_state_order_HSMM[2]]), lwd = 3, lty = 2)
lines(density(NBapproxVARHSMM_NLP_params$phim1[,estimated_state_order_HSMM_NLP_nol1[2]]), lwd = 3, lty = 1, col = "grey")
abline(v = 1, lwd = 3, lty = 2, col = "red")

plot(density(NBapproxVARHSMM_l1ball_NLP_params$phim1[,estimated_state_order_HSMM_NLP[3]]), xlab = "phi^{-1}", ylab = "Density", lwd = 3, xlim = c(0, 10))
lines(density(NBapproxVARHSMM_l1ball_params$phim1[,estimated_state_order_HSMM[3]]), lwd = 3, lty = 2)
lines(density(NBapproxVARHSMM_NLP_params$phim1[,estimated_state_order_HSMM_NLP_nol1[3]]), lwd = 3, lty = 1, col = "grey")
abline(v = 1, lwd = 3, lty = 2, col = "red")

```

# Final Comparison 

```{r VAR_HMM_HSMM_l1ball_comparison, include=TRUE,echo=TRUE, eval=TRUE, cache=FALSE}
library(xtable)
library(knitr)

VAR_HMM_HSMM_l1ball_comparison_table <- data.frame("Method" = c("HMM", "HSMM-LP", "HSMM-NLP", "HSMM-NLP-shrinkage"),
                        "marg-llk" = c(VARHMM_l1ball_bridge$logml, NBapproxVARHSMM_l1ball_bridge$logml, NBapproxVARHSMM_l1ball_NLP_bridge$logml, NBapproxVARHSMM_NLP_bridge$logml),
                        "State - MAE" = c(VARHMM_l1ball_state_errors, NBapproxVARHSMM_l1ball_state_errors, NBapproxVARHSMM_l1ball_NLP_state_errors, NBapproxVARHSMM_NLP_state_errors),
                        "State - BS" = formatC(c(VARHMM_l1ball_breir_score, NBapproxVARHSMM_l1ball_breir_score, NBapproxVARHSMM_l1ball_NLP_breir_score, NBapproxVARHSMM_NLP_breir_score), format = "e"),
                        "VAR - MAE" = formatC(c(VARHMM_l1ball_beta1_MSE+VARHMM_l1ball_beta2_MSE+VARHMM_l1ball_beta3_MSE,
                                                   NBapproxVARHSMM_l1ball_beta1_MSE+NBapproxVARHSMM_l1ball_beta2_MSE+NBapproxVARHSMM_l1ball_beta3_MSE,
                                                   NBapproxVARHSMM_l1ball_NLP_beta1_MSE+NBapproxVARHSMM_l1ball_NLP_beta2_MSE+NBapproxVARHSMM_l1ball_NLP_beta3_MSE,
                                                   NBapproxVARHSMM_NLP_beta1_MSE+NBapproxVARHSMM_NLP_beta2_MSE+NBapproxVARHSMM_NLP_beta3_MSE)/(K*D*D*P), format = "e"),
                        "VAR - BS" = formatC(c(VARHMM_l1ball_breir_score_beta, NBapproxVARHSMM_l1ball_breir_score_beta, NBapproxVARHSMM_l1ball_NLP_breir_score_beta, NBapproxVARHSMM_NLP_breir_score_beta), format = "e")
                        )

                          
xtable(VAR_HMM_HSMM_l1ball_comparison_table, include.rownames = FALSE, digits = 3)

kable(VAR_HMM_HSMM_l1ball_comparison_table)



NBapproxVARHSMM_l1ball_beta2_MSE
NBapproxVARHSMM_l1ball_NLP_beta2_MSE
NBapproxVARHSMM_NLP_beta2_MSE

```

